import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import solve_ivp   # ivp stands for initial value problem
def simplefun(t, y):  # right hand side of the dy/dt = f(t,y) equation
    a = -1
    dydt = a*y 
    return [dydt]
y0 = [1]      # initial condition (t=0) for dependent variable
t0 = 0
tfinal = 3
ts = np.linspace(t0, tfinal, (tfinal-t0)*10) # sampled vector of time (independent variable)
sol = solve_ivp(simplefun, [t0, tfinal], y0, t_eval=ts)
plt.plot(sol.t, sol.y[0], sol.t, np.exp(-1*sol.t))
# The advantage is that this method of solve_ivp can be used to get multiple solutions for multiple initial conditions also.


import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import solve_ivp #for solving initial value problem using scipy
def lotkavolterra(t, y):
    a = 0.7
    c = 0.007
    b = 1.
    pr = y[0] # population of rabbits
    pf = y[1] # population of foxes
    dprdt = a*pr - c*pr*pf
    dpfdt = c*pr*pf - b*pf
    return np.array([dprdt, dpfdt]) # returning an array instead of list
p0 = [70, 50]      # initial condition
t0 = 0
tfinal = 30 
ts = np.linspace(t0, tfinal, 20*(tfinal-t0))
sol = solve_ivp(lotkavolterra, [t0, tfinal], p0, t_eval=ts)
pr = sol.y[0]                
pf = sol.y[1]                
plt.plot(sol.t, pr, label='rabbits')
plt.plot(sol.t, pf, '-o', label='foxes')
plt.legend()
plt.xlabel('t')


def eulerf(f,tspan,y0,dt):  # a starter version of the Euler Forward algorithm
# f - the function that defines the derivative or right hand side of the ODE
# tspan - array with starttime and endtime
# y0 - initial value of the output variable or y(t=0)
# dt - time step for the solver
    n = int(np.diff(tspan)/dt)  # number of intervals, has to be an integer for linspace to work 
    t = np.linspace(tspan[0],tspan[1],n+1) # time vector
    y = np.zeros([n+1,len(y0)])   # initialize the output vector
    y[0,:] = y0           # set the initial value of output
    for i in range(0,n): 
        y[i+1,:] = y[i,:] + dt*f(t[i],y[i,:])  # loop over all the time steps i to compute y vector
    return y, t         # return the solution and time vectors
tspan = np.array([t0, tfinal]) # array with starttime and endtime
tstep = 0.1 # timestep
ye, te = eulerf(lotkavolterra, tspan, p0, tstep)    
plt.plot(te, ye[:])
plt.ylabel('population')


fig,axs = plt.subplots(nrows=2, ncols=1, figsize=(10,8))
def eulerf(f,tspan,y0,dt): # defining eulerf function
    n = int(np.diff(tspan)/dt) 
    t = np.linspace(tspan[0],tspan[1],n+1) 
    y = np.zeros([n+1,len(y0)])  # defining subplot array
    y[0,:] = y0           
    for i in range(0,n): 
        y[i+1,:] = y[i,:] + dt*f(t[i],y[i,:])  
    return y, t         
tspan = np.array([t0, tfinal]) # Trying timesteps of 0.05, 0.1, 0.2
ye, te = eulerf(lotkavolterra, tspan, p0, 0.05) 
axs[0].plot(te,ye[:,0],'y', label=0.05)
axs[1].plot(te,ye[:,1],'y', label=0.05)
ye, te = eulerf(lotkavolterra, tspan, p0, 0.1)
axs[0].plot(te,ye[:,0],'r--', label=0.1)
axs[1].plot(te,ye[:,1],'r--', label=0.1)
ye, te = eulerf(lotkavolterra, tspan, p0, 0.2)
axs[0].plot(te,ye[:,0],'b-', label=0.2)
axs[1].plot(te,ye[:,1],'b-', label=0.2)
axs[0].set_title("Rabbits")
axs[1].set_title("Foxes")
axs[0].legend()
axs[1].legend()
plt.show()


fig,axs = plt.subplots(nrows=2, ncols=1, figsize=(8,10))
ye, te = eulerf(lotkavolterra, tspan, p0, 0.1)
axs[1].plot(ye[:,0],ye[:,1]) # plotting graphs for simple solution and forward euler method
axs[1].set_xlabel('Rabbits')
axs[1].set_ylabel('Foxes')
axs[1].set_title("Forword Euler Method")
axs[0].plot( pr, pf)
axs[0].set_xlabel('Rabbits')
axs[0].set_ylabel('Foxes')
axs[0].set_title("Simple Solution")
axs[1].set_title("Forword Euler Method")
plt.show()


def RungeKutta2(f,tspan,y0,dt): # defining RungeKutta RK2 function
    n = int(np.diff(tspan)/dt)
    t = np.linspace(tspan[0],tspan[1],n+1) 
    y = np.zeros([n+1,len(y0)])   # defining array
    y[0,:] = y0                   
    for i in range(0,n):
      k1 = f(t[i],y[i,:])      
      k2 = f(t[i]+(dt/2),y[i,:] + (k1*dt/2))                  
      y[i+1,:] = y[i,:] + (k2*dt)
    return y, t
    y, t = RungeKutta2(lotkavolterra, tspan, p0, 0.1)
    print(y, t)
    
y, t = RungeKutta2(lotkavolterra, tspan, p0, 0.1)
fig, ax = plt.subplots(figsize=(16,8))
# plotting graphs for Fox & Rabbit - Forward euler & RK2
ax.plot(te, ye[:,1], '--b', label= "Foxes- forword euler")
ax.plot(t, y[:,1], 'g', label="Foxes- rungekutta2")
ax.plot(te, ye[:,0],'--m', label="Rabbits- forword euler")
ax.plot(t, y[:,0], 'r', label="Rabbits- rungekutta2")
ax.legend()
plt.xlabel('time')
plt.ylabel('population')


def RungeKutta4(f,tspan,y0,dt): # defining RungeKutta RK2 function
    n = int(np.diff(tspan)/dt)    
    t = np.linspace(tspan[0],tspan[1],n+1)
    y = np.zeros([n+1,len(y0)])   # defining array
    y[0,:] = y0                   
    for i in range(0,n):
      k1 = f(t[i],y[i,:])      
      k2 = f(t[i]+(dt/2),y[i,:] + (k1*dt/2)) 
      k3 = f(t[i]+(dt/2),y[i,:] + (k2*dt/2)) 
      k4 = f(t[i]+dt,y[i,:] + (k3*dt))
      kf = (k1 + 2*k2 + 2*k3 + k4)/6           
      y[i+1,:] = y[i,:] + (kf*dt)
    return y, t
    y2, t2 = RungeKutta4(lotkavolterra, tspan, p0, 0.1)
    print(y,t)
    
    
y2, t2 = RungeKutta4(lotkavolterra, tspan, p0, 0.1)
fig, ax = plt.subplots(figsize=(16,8))
# plotting graphs for Fox & Rabbit - RK2 vs RK4
ax.plot(t, y[:,1], "--g", label="Foxes by rungekutta2")
ax.plot(t2, y2[:,1], "b", label="Foxes by rungekutta4")
ax.plot(t, y[:,0],"--o", label="Rabbits by rungekutta2")
ax.plot(t2, y2[:,0], "r", label="Rabbits by rungekutta4")
ax.legend()
plt.xlabel('time')
plt.ylabel('population')


import matplotlib.pyplot as plt
def harmonic(t,x):
  return np.array([x[1], (F-(c*x[1])-(k*x[0]))/m])
from os import read
# ploting the function
m=1
c=1/4
k=1
F=0
p0 = [1,0]
tstep = 0.1
xrk4, trk4 = RungeKutta4 (harmonic, tspan, p0, tstep)
fig, axes = plt.subplots()
axes.plot(trk4,xrk4[:,0] ,'r', lw=0.1, marker='+', ),
axes.set_title('damped linear harmonic oscillator')
axes.set_xlabel('t')
axes.set_ylabel('x')
